import { Router, Request, Response } from 'express';
import mongoose from 'mongoose';
import createDynamicModel from '../../../infrastructure/database/dynamicModel';
import createDynamicModelById from '../../../infrastructure/database/dynamicModelById';
import dotenv from 'dotenv';

// Cargar las variables de entorno
dotenv.config();

const mongoDB = process.env.MONGO_URI || '';
const router = Router();

// Conexión a MongoDB
mongoose.connect(mongoDB)
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => console.error('Error connecting to MongoDB:', err));

// ================================================
// CRUD OPERATIONS - BULK ENDPOINTS
// ================================================

// Obtener áreas por IDs en bulk
router.post('/get-areas/bulk', async (req: Request, res: Response) => {
  const { grado, ids } = req.body;
  const DynamicModel = createDynamicModel("Area", {});
  const DetailsPreguntas = createDynamicModel('detail_preguntas', {});
  try {


    
    const result = [];
    for (const idAsignature of ids) {
      const document: any = await DynamicModel.findById(idAsignature);
      if (!document) {
        continue; // Ignorar si no existe
      }

    console.log('Grado:', grado,{ids} ,'asigantura',document);
      const question: any[] = await DetailsPreguntas.find({
        grado,
        tipo_platform: 'App',
        area: document.value
      });
      const preguntas = question.map(q => q.id);
      const doc = {
        ...document._doc,
        childrents: preguntas
      };
      result.push(doc);
    }
    res.status(200).send(result);
  } catch (error) {
    console.log(error);
    res.status(500).send(error);
  }
});
// Obtener asignaturas por IDs en bulk
router.post('/get-asignatures/bulk', async (req: Request, res: Response) => {
  const { grado, ids } = req.body;
  const DynamicModel = createDynamicModel("Asignaturas", {});
  const DetailsPreguntas = createDynamicModel('detail_preguntas', {});
  try {

    const result = [];
    for (const idAsignature of ids) {
      const document: any = await DynamicModel.findById(idAsignature);
      if (!document) {
        continue; // Ignorar si no existe
      }
      const question: any[] = await DetailsPreguntas.find({
        grado,
        tipo_platform: 'App',
        asignatura: document.value
      });
      const preguntas = question.map(q => q.id);
      const doc = {
        ...document._doc,
        childrents: preguntas
      };
      result.push(doc);
    }
    res.status(200).send(result);
  } catch (error) {
    console.log(error);
    res.status(500).send(error);
  }
});
// Obtener documentos por IDs en bulk (genérico)
router.post('/:collectionName/bulk', async (req: Request, res: Response) => {
  try {
    const { collectionName } = req.params;
    const { ids } = req.body;
    // Validación básica
    if (!ids || !Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({
        error: 'Se requiere un array "ids" con al menos un elemento',
      });
    }
    const DynamicModel = createDynamicModel(collectionName, {});
    const documents = await DynamicModel.find({ _id: { $in: ids } });
    if (!documents || documents.length === 0) {
      return res.status(404).json({
        message: 'No se encontraron documentos para los IDs especificados.',
      });
    }
    return res.status(200).json(documents);
  } catch (error) {
    console.error('Error en /:collectionName/bulk', error);
    return res.status(500).json({
      error: 'Error interno del servidor',
      details: error,
    });
  }
});
// Actualizar múltiples documentos
router.put('/:collectionName/bulk-update', async (req: Request, res: Response) => {
  try {
    const { collectionName } = req.params;
    const { students } = req.body;
    if (!Array.isArray(students) || students.length === 0) {
      return res.status(400).json({ error: 'Se requiere un array de estudiantes para actualizar.' });
    }
    const DynamicModel = createDynamicModel(collectionName, {});
    const updated: any[] = [];
    const notFound: any[] = [];
    for (const student of students) {
      const { id_estudiante, ...rest } = student;
      if (!id_estudiante) {
        continue; // Saltar si no tiene ID
      }
      const result = await DynamicModel.findOneAndUpdate(
        { id_estudiante },
        { $set: rest },
        { new: true } // Devuelve el documento actualizado
      );
      if (result) {
        updated.push(result);
      } else {
        notFound.push(id_estudiante);
      }
    }
    return res.status(200).json({
      message: `${updated.length} estudiantes actualizados.`,
      actualizados: updated,
      no_encontrados: notFound
    });
  } catch (error) {
    console.error('Error en bulk-update:', error);
    return res.status(500).json({
      error: 'Error interno del servidor',
      details: error instanceof Error ? error.message : error
    });
  }
});

// Crear múltiples documentos (solo si no existen)
router.post('/:collectionName/bulk-create-unique', async (req: Request, res: Response) => {
  try {
    const { collectionName } = req.params;
    const { students } = req.body;
    if (!Array.isArray(students) || students.length === 0) {
      return res.status(400).json({ error: 'Se requiere un array de estudiantes.' });
    }
    const DynamicModel = createDynamicModel(collectionName, {});
    const ids = students.map((s: any) => s.id_estudiante);

    // Buscar estudiantes ya existentes por id_estudiante
    const existing = await DynamicModel.find({ id_estudiante: { $in: ids } }).lean();
    const existingIds = new Set(existing.map((e: any) => e.id_estudiante));

    // Filtrar y limpiar los que aún no existen
    const toInsert = students
      .filter((s: any) => !existingIds.has(s.id_estudiante))
      .map((s: any) => {
        const clean = { ...s };
        if (clean.id === null || clean.id === undefined) {
          delete clean.id;
        }
        return clean;
      });

    let insertedDocs: any[] = [];
    if (toInsert.length > 0) {
      insertedDocs = await DynamicModel.insertMany(toInsert);
    }

    return res.status(200).json({
      message: `${insertedDocs.length} estudiantes creados. ${existing.length} ya existían.`,
      creados: insertedDocs,
      existentes: existing
    });
  } catch (error) {
    console.error('Error en bulk-create-unique:', error);
    return res.status(500).json({
      error: 'Error interno del servidor',
      details: error instanceof Error ? error.message : error
    });
  }
});

// ================================================
// SEARCH ENDPOINTS
// ================================================
// Buscar documentos por campo dinámico
router.get('/:collectionName/search/:field/:value', async (req: Request, res: Response) => {
  const { collectionName, field, value } = req.params;
  const DynamicModel = createDynamicModel(collectionName, {});
  try {
    // Realizar la búsqueda dinámica
    const query = { [field]: value }; // Construye el filtro dinámicamente
    const documents = await DynamicModel.find(query);
    if (documents.length === 0) {
      return res.status(404).send({ message: `No se encontraron documentos para el campo "${field}" con el valor "${value}".` });
    }
    res.status(200).send(documents);
  } catch (error) {
    console.error(`Error buscando por campo dinámico "${field}" con valor "${value}":`, error);
    res.status(500).send({ message: 'Error interno del servidor', error });
  }
});

// Buscar documentos por múltiples campos
router.get('/:collectionName/multi-search/:query', async (req: Request, res: Response) => {
  const { collectionName, query } = req.params;
  const fields = req.query.fields ? (req.query.fields as string).split(',') : [];
  const DynamicModel = createDynamicModel(collectionName, {});
  try {
    const searchPromises = fields.map(field =>
      DynamicModel.find({ [field]: new RegExp(query, 'i') })
    );
    const results = await Promise.all(searchPromises);
    const documents = results.flat();
    res.status(200).send(documents);
  } catch (error) {
    res.status(500).send(error);
  }
});

// Buscar por categoría
router.get('/:collectionName/category/:category', async (req: Request, res: Response) => {
  const { collectionName, category } = req.params;
  const DynamicModel = createDynamicModel(collectionName, {});
  try {
    const documents = await DynamicModel.find({ category });
    res.status(200).send(documents);
  } catch (error) {
    res.status(500).send(error);
  }
});

// ================================================
// CREATE ENDPOINTS
// ================================================


// Crear documento (con o sin ID específico)

router.post('/:collectionName/:id?', async (req: Request, res: Response) => {
  const { collectionName, id } = req.params;
  const schemaDefinition = req.body.schema || {};
  const data = req.body.data || req.body || {};
  const DynamicModel = createDynamicModel(collectionName, schemaDefinition);
  try {
    const idAux = id ?? data.id_student;
    const documentData = idAux ? { ...data, id: idAux } : data;
    const document = new DynamicModel(documentData);
    await document.save();
    res.status(201).send(document);
  } catch (error) {
    res.status(400).json({
      message: 'Error al guardar el documento',
      error: error instanceof Error ? error.message : error
    });
  }
});
// router.post('/:collectionName/:id?', async (req: Request, res: Response) => {
//   const { collectionName, id } = req.params;
//   const schemaDefinition = req.body.schema || {};
//   const data = req.body.data || req.body || {};
//   const DynamicModel = createDynamicModel(collectionName, schemaDefinition);
//   try {
//     const _id = id ?? data.id_student;
//     console.log(collectionName,_id);
//     const documentData = _id ? { ...data, _id } : data;
//     const document = new DynamicModel(documentData);
//     await document.save();
//     res.status(201).send(document);
//   } catch (error) {
//     res.status(400).json({
//       message: 'Error al guardar el documento',
//       error: error instanceof Error ? error.message : error
//     });
//   }
// });


router.get('/generate-simulacro/:value/:cantidad', async (req: Request, res: Response) => {
  const { value, cantidad } = req.params;
  const GradosModel = createDynamicModel('Grados', {});
  const Asignaturas = createDynamicModel('Asignaturas', {});
  const DetailsPreguntas = createDynamicModel('detail_preguntas', {});
  try {
    const document: any = await GradosModel.findOne({ value: value });
    if (!document) {
      return res.status(404).send({ message: "Grado no encontrado" });
    }

    // Calculamos el número de preguntas por asignatura dividiendo 40 entre el número de asignaturas
    const numAsignaturas = document.childrents.length;
    const preguntasPorAsignatura = Math.floor(40 / numAsignaturas);

    const pregunt: any = await DetailsPreguntas.find({
      programa: value,
      tipo_platform: 'App'
    })

    // Group questions by area
    const groupedByArea = pregunt.reduce((acc: any, curr: any) => {
      const area = curr.area || 'Sin área';
      if (!acc[area]) {
        acc[area] = [];
      }
      acc[area].push(curr.id);
      return acc;
    }, {});

    const allIds = Object.values(groupedByArea).flat();

    //validamos si cantidad es mayor a 0 
    const cantidadInt = parseInt(cantidad);
    const cantidadInt2 = cantidadInt > 2 ? cantidadInt : 40;

    // Elegir 40 aleatorios sin dañar el orden original
    const shuffled = [...allIds].sort(() => Math.random() - 0.5); // shuffle
    const selectedSet = new Set(shuffled.slice(0, cantidadInt2)); // tomar 40 al azar

    // Filtrar de allIds, pero respetando su orden original
    const preguntas = allIds.filter(id => selectedSet.has(id));

    res.status(200).send({ data: preguntas });
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "Error en el servidor", error });
  }
});


// Obtener un documento por ID en una colección específica
router.get('/get-asignatures/:idAsignature/:valueGrado', async (req: Request, res: Response) => {
  const { idAsignature, valueGrado } = req.params;
  const DynamicModel = createDynamicModel("Asignaturas", {});
  const DetailsPreguntas = createDynamicModel('detail_preguntas', {});
  try {
    const document: any = await DynamicModel.findById(idAsignature);
    //recorrer las preguntar que trae aignaturas por id unavez se tenga eso 
    if (!document) {
      return res.status(404).send();
    }
    const questions: any[] = await DetailsPreguntas.find({
      grado: valueGrado,
      tipo_platform: 'App',
      asignatura: document.value
    });
    const preguntas = questions.map(q => q.id);
    const doc = { ...document._doc, childrents: preguntas };

    res.status(200).send(doc);
  } catch (error) {
    console.error('Error en get-asignatures:', error);
    res.status(500).send(error);
  }
});
// ================================================
// READ ENDPOINTS
// ================================================

// Obtener todos los documentos de una colección
router.get('/:collectionName', async (req: Request, res: Response) => {
  const { collectionName } = req.params;
  const DynamicModel = createDynamicModel(collectionName, {});
  try {
    const documents = await DynamicModel.find();
    res.status(200).send(documents);
  } catch (error) {
    res.status(500).send(error);
  }
});

// Obtener pregunta específica (endpoint especializado)
router.get('/get-questions/:idquestion/:idProgram/', async (req: Request, res: Response) => {
  const { idquestion } = req.params;
  const DynamicModel = createDynamicModel("detail_preguntas", {});
  try {
    const document = await DynamicModel.findById(idquestion);
    if (!document) {
      return res.status(404).send();
    }
    res.status(200).send(document);
  } catch (error) {
    console.error('Error en get-questions:', error);
    res.status(500).send(error);
  }
});


// Obtener documento por ID
router.get('/:collectionName/:id', async (req: Request, res: Response) => {
  const { collectionName, id } = req.params;
  const DynamicModel = createDynamicModel(collectionName, {});
  try {
    const document = await DynamicModel.findById(id);
    if (!document) {
      return res.status(404).send();
    }
    res.status(200).send(document);
  } catch (error) {
    console.error(`Error obteniendo documento ${id} de ${collectionName}:`, error);
    res.status(500).send(error);
  }
});

// Obtener documento por ID de estudiante
router.get('/:collectionName/convert_id/:id', async (req: Request, res: Response) => {
  const { collectionName, id } = req.params;
  const DynamicModel = createDynamicModelById(collectionName, {});
  try {
    const document: any = await DynamicModel.findOne({ id_student: id });
    if (!document) {
      return res.status(404).send();
    }
    res.status(200).send(document);
  } catch (error) {
    console.error(`Error obteniendo documento por id_student ${id}:`, error);
    res.status(500).send(error);
  }
});

// Obtener posición del estudiante en ranking
router.get('/get-my-position/:grado/:id_student', async (req: Request, res: Response) => {
  const { id_student, grado } = req.params;
  const Students = createDynamicModel('Estudiantes', {});
  try {
    const student: any = await Students.findOne({ id_student });
    if (!student) {
      return res.status(200).send({ posicion: 0, n_estudiantes: 0 });
    }
    
    const gradoDoc = student.grados.find((g: any) => g.grado === grado);
    if (!gradoDoc || gradoDoc.scoreSimulacro == 0) {
      return res.status(200).send({ posicion: 0, n_estudiantes: 0 });
    }
    
    const estudiantes: any[] = await Students.find();
    const scoresSimulacro: number[] = [];
    
    for (const otherStudent of estudiantes) {
      if (otherStudent.id_student === id_student) continue;
      
      for (const g of otherStudent.grados) {
        if (g.grado === grado) {
          scoresSimulacro.push(g.scoreSimulacro || 0);
        }
      }
    }
    
    scoresSimulacro.push(gradoDoc.scoreSimulacro);
    scoresSimulacro.sort((a, b) => b - a);
    
    const posicion = scoresSimulacro.indexOf(gradoDoc.scoreSimulacro) + 1;
    const n_estudiantes = estudiantes.length;
    
    res.status(200).send({ posicion, n_estudiantes });
  } catch (error) {
    console.error('Error obteniendo posición:', error);
    res.status(500).send(error);
  }
});


// ================================================
// UPDATE & DELETE ENDPOINTS
// ================================================

// Actualizar documento por ID
router.put('/:collectionName/:id', async (req: Request, res: Response) => {
  const { collectionName, id } = req.params;
  const data = req.body;
  const DynamicModel = createDynamicModelById(collectionName, {});
  try {
    const document = await DynamicModel.findByIdAndUpdate(id, data, { new: true, runValidators: true });
    if (!document) {
      return res.status(404).send();
    }
    res.status(200).send(document);
  } catch (error) {
    console.error(`Error actualizando documento ${id}:`, error);
    res.status(400).send(error);
  }
});

// Eliminar documento por ID
router.delete('/:collectionName/:id', async (req: Request, res: Response) => {
  const { collectionName, id } = req.params;
  const DynamicModel = createDynamicModel(collectionName, {});
  try {
    const document = await DynamicModel.findByIdAndDelete(id);
    if (!document) {
      return res.status(404).send();
    }
    res.status(200).send(document);
  } catch (error) {
    console.error(`Error eliminando documento ${id}:`, error);
    res.status(500).send(error);
  }
});

// Obtener preguntas por tipo y área
router.get('/preguntas-por-tipo/:idPrograma/:type/:value', async (req: Request, res: Response) => {
  const { idPrograma, value } = req.params;
  const GradosModel = createDynamicModel('Grados', {});
  const DetailsPreguntas = createDynamicModel('detail_preguntas', {});
  try {
    const grados = await GradosModel.find({ value: idPrograma });
    if (!grados || grados.length === 0) {
      return res.status(404).send();
    }
    
    const preguntas = await DetailsPreguntas.find({
      area: value,
      tipo_platform: { $in: [null, "Examen"] },
      programa: idPrograma,
      grado: idPrograma,
    }, {
      "pregunta": 1,
      "cod": 1,
      "id": 1,
      "area": 1
    });
    
    res.status(200).send(preguntas);
  } catch (error) {
    console.error('Error obteniendo preguntas por tipo:', error);
    res.status(500).send(error);
  }
});

// Obtener nivel académico por puntaje
router.get('/:collectionName/:id/:score', async (req: Request, res: Response) => {
  const { collectionName, id, score } = req.params;
  try {
    const academicLevelsCollection = mongoose.connection.collection(collectionName);
    const document = await academicLevelsCollection.findOne({ _id: new mongoose.Types.ObjectId(id) });
    
    if (!document) {
      return res.status(404).send({ message: 'Academic level not found' });
    }

    const scoreValue = parseInt(score, 10);
    let previousLevelColor = null;

    for (let index = 0; index < document.types_levels.length; index++) {
      const type = document.types_levels[index];
      const min = parseInt(type.min, 10);
      const max = parseInt(type.max, 10);
      
      if (document.types_levels.length > 1 && index > 0) {
        previousLevelColor = document.types_levels[index - 1].color;
      }
      
      if (scoreValue >= min && scoreValue <= max) {
        for (const level of type.levels) {
          const puntaje = parseInt(level.puntaje, 10);
          if (scoreValue <= puntaje) {
            const result = {
              level: level.level,
              currentColor: type.color,
              typeName: type.name,
              previousColor: previousLevelColor
            };
            return res.status(200).send(result);
          }
        }
      }
    }

    res.status(400).send({ message: 'Score does not match any level' });
  } catch (error) {
    console.error('Error fetching academic level:', error);
    res.status(500).send(error);
  }
});


export default router;